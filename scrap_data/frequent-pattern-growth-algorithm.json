[
  {
    "input": "How FP-Growth Works",
    "output": "Here's how it works in simple terms:\nImagine you’re organizing a party and want to know popular food combinations without asking every guest repeatedly.\nThis is exactly how FP-Growth finds frequent patterns efficiently."
  },
  {
    "input": "Working of FP- Growth Algorithm",
    "output": "Lets jump to the usage of FP- Growth Algorithm and how it works with reallife data. Consider the following data:\nThe above-given data is a hypothetical dataset of transactions with each letter representing an item. The frequency of each individual item is computed:-\nLet the minimum support be 3. AFrequent Pattern setis built which will contain all the elements whose frequency is greater than or equal to the minimum support. These elements are stored in descending order of their respective frequencies. After insertion of the relevant items, the set L looks like this:-L = {K : 5, E : 4, M : 3, O : 4, Y : 3}Now for each transaction the respectiveOrdered-Item setis built. It is done by iterating the Frequent Pattern set and checking if the current item is contained in the transaction in question. If the current item is contained the item is inserted in the Ordered-Item set for the current transaction. The following table is built for all the transactions:\nNow all the Ordered-Item sets are inserted into a Tree Data Structure.a) Inserting the set {K, E, M, O, Y}Here all the items are simply linked one after the other in the order of occurrence in the set and initialise the support count for each item as 1. For inserting {K, E, M, O, Y} we traverse the tree from the root. If a node already exists for an item, we increase its support count. If it doesn’t exist, we create a new node for that item and link it to the previous item.\nb) Inserting the set {K, E, O, Y}Till the insertion of the elements K and E, simply the support count is increased by 1. On inserting O we can see that there is no direct link between E and O, therefore a new node for the item O is initialized with the support count as 1 and item E is linked to this new node. On inserting Y, we first initialize a new node for the item Y with support count as 1 and link the new node of O with the new node of Y.\nc) Inserting the set {K, E, M}Here simply the support count of each element is increased by 1.\nd) Inserting the set {K, M, Y}Similar to step b), first the support count of K is increased, then new nodes for M and Y are initialized and linked accordingly.\n\ne) Inserting the set {K, E, O}Here simply the support counts of the respective elements are increased. Note that the support count of the new node of item O is increased.\nThe Conditional Pattern Base for each item consists of the set of prefixes of all paths in the FP-tree that lead to that item. Note that the items in the below table are arranged in the ascending order of their frequencies.\nNow for each item, theConditional Frequent Pattern Tree is built.It is done by taking the set of elements that is common in all the paths in the Conditional Pattern Base of that item and calculating its support count by summing the support counts of all the paths in the Conditional Pattern Base.\nFrom the Conditional Frequent Pattern tree theFrequent Pattern rulesare generated by pairing the items of the Conditional Frequent Pattern Tree set to the corresponding to the item as given in the below table.\nFor each row two types of association rules can be inferred for example for the first row which contains the element, the rulesK -> Y and Y -> Kcan be inferred. To determine the valid rule, the confidence of both the rules is calculated and the one with confidence greater than or equal to the minimum confidence value is retained.\nFrequent Pattern Growth (FP-Growth) algorithm improves upon the Apriori algorithm by eliminating the need for multiple database scans and reducing computational overhead. By using a Tree data structure and focusing on ordered-item sets it efficiently mines frequent item sets making it a faster and more scalable solution for large datasets making it useful tool for data mining."
  }
]