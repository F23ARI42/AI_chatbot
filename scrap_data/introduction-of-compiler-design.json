[
  {
    "input": "Operations of Compilers",
    "output": "These are some operations that are done by the compiler.\nBreaks source programs into smaller parts.\nEnables the creation of symbol tables and intermediate representations.\nHelps in Error Detection.\nSaves all codes and variables.\nAnalyses the full program and translates it.\nConvert source code to machine code."
  },
  {
    "input": "Compiler and Other Language Processing Systems",
    "output": "We know a computer is a logical assembly ofSoftware and Hardware. The hardware knows a language, that is hard for us to grasp, consequently, we tend to write programs in a high-level language, that is much less complicated for us to comprehend and maintain in our thoughts. Now, these programs go through a series of transformations so that they can readily be used by machines. This is where language procedure systems come in handy.\nPre-Processor:The pre-processor removes all the #include directives by including the files called file inclusion and all the #define directives using macro expansion. It performs file inclusion, augmentation, macro-processing, etc. For example: Let in the source program, it is written #include \"Stdio. h\". Pre-Processor replaces this file with its contents in the produced output.\nAssembler:Assembly Language neither in binary form nor high level. It is an intermediate state that is a combination of machine instructions and some other useful data needed for execution. For every platform (Hardware + OS) we will have an assembler. They are not universal since for each platform we have one. The output of the assembler is called an object file. Its translates assembly language to machine code.\nCompiler:The compiler is an intelligent program as compared to an assembler. The compiler verifies all types of limits, ranges, errors, etc. Compiler program takes more time to run and it occupies a huge amount of memory space. The speed of the compiler is slower than other system software. It takes time because it enters through the program and then does the translation of the full program.\nInterpreter:An interpreter converts high-level language into low-level machine language, just like a compiler. But they are different in the way they read the input. The Compiler in one go reads the inputs, does the processing, and executes the source code whereas the interpreter does the same line by line. A compiler scans the entire program and translates it as a whole into machine codewhereas an interpretertranslates the program one statement at a time. Interpreted programs are usually slower concerning compiled ones.\nLoader/Linker:Loader/Linkerconverts the relocatable code into absolute code and tries to run the program resulting in a running program or an error message (or sometimes both can happen). Linker loads a variety of object files into a single file to make it executable. Then loader loads it in memory and executes it.Linker:The basic work of a linker is to merge object codes (that have not even been connected), produced by the compiler, assembler, standard library function, and operating system resources.Loader:The codes generated by the compiler, assembler, and linker are generally re-located by their nature, which means to say, the starting location of these codes is not determined, which means they can be anywhere in the computer memory. Thus the basic task of loaders to find/calculate the exact address of these memory locations.\nLinker:The basic work of a linker is to merge object codes (that have not even been connected), produced by the compiler, assembler, standard library function, and operating system resources.\nLoader:The codes generated by the compiler, assembler, and linker are generally re-located by their nature, which means to say, the starting location of these codes is not determined, which means they can be anywhere in the computer memory. Thus the basic task of loaders to find/calculate the exact address of these memory locations."
  },
  {
    "input": "Types of Compilers",
    "output": "Self Compiler:When the compiler runs on the same machine and produces machine code for the same machine on which it is running then it is called as self compiler or resident compiler.\nCross Compiler: The compiler may run on one machine and produce the machine codes for other computers then in that case it is called a cross-compiler. It is capable of creating code for a platform other than the one on which the compiler is running.\nSource-to-Source Compiler:A Source-to-Source Compiler or transcompiler or transpiler is a compiler that translates source code written in one programming language into the source code of another programming language.\nSingle Pass Compiler:When all the phases of the compiler are present inside a single module, it is simply called a single-pass compiler. It performs the work of converting source code to machine code.\nTwo Pass Compiler:Two-pass compiler is a compiler in which the program is translated twice, once from the front end and the back from the back end known as Two Pass Compiler.\nMulti-Pass Compiler:When several intermediate codes are created in a program and a syntax tree is processed many times, it is called Multi-Pass Compiler. It breaks codes into smaller programs.\nJust-in-Time (JIT) Compiler: It is a type of compiler that converts code into machine language during program execution, rather than before it runs. It combines the benefits of interpretation (real-time execution) and traditional compilation (faster execution).\nAhead-of-Time (AOT) Compiler:It converts the entire source code into machine code before the program runs. This means the code is fully compiled during development, resulting in faster startup times and better performance at runtime.\nIncremental Compiler:It compiles only the parts of the code that have changed, rather than recompiling the entire program. This makes the compilation process faster and more efficient, especially during development."
  },
  {
    "input": "History of Compilers",
    "output": "In the 1950s, Grace Hopper developed the first compiler, leading to languages like FORTRAN (1957), LISP (1958), and COBOL (1959). The 1960s saw innovations like ALGOL, and the 1970s introduced C and Pascal. Modern compilers focus on optimization, supporting object-oriented features and Just-in-Time compilation. Compilers have revolutionized programming, enabling complex systems and improving software efficiency."
  }
]